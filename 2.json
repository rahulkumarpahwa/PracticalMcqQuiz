[
  {
    "question": "JDBC stands for:",
    "option1": "Java DataBase Connectivity",
    "option2": "Java Data Binary Connection",
    "option3": "Java Dual Base Connection",
    "option4": "Java Drive Base Client",
    "option5": "Java DataBuffer Client",
    "solution": "Java DataBase Connectivity"
  },
  {
    "question": "Which package contains JDBC classes?",
    "option1": "java.db",
    "option2": "javax.sql",
    "option3": "java.jdbc",
    "option4": "java.sql",
    "option5": "jdbc.core",
    "solution": "java.sql"
  },
  {
    "question": "Which interface is used to establish a connection?",
    "option1": "Driver",
    "option2": "DriverManager",
    "option3": "Connection",
    "option4": "JDBCConnector",
    "option5": "DBSocket",
    "solution": "Connection"
  },
  {
    "question": "Which method establishes a database connection?",
    "option1": "DriverManager.getConnection()",
    "option2": "DB.connect()",
    "option3": "SQL.connect()",
    "option4": "Database.get()",
    "option5": "SQLDriver.get()",
    "solution": "DriverManager.getConnection()"
  },
  {
    "question": "Which interface is used to execute SQL queries?",
    "option1": "Command",
    "option2": "Statement",
    "option3": "SQLQuery",
    "option4": "QueryExec",
    "option5": "Runner",
    "solution": "Statement"
  },
  {
    "question": "Which method executes SELECT queries?",
    "option1": "execute()",
    "option2": "executeQuery()",
    "option3": "queryExec()",
    "option4": "run()",
    "option5": "fetch()",
    "solution": "executeQuery()"
  },
  {
    "question": "Which JDBC interface stores returned data?",
    "option1": "ResultSet",
    "option2": "SQLSet",
    "option3": "DataTable",
    "option4": "Cursor",
    "option5": "SelectionSet",
    "solution": "ResultSet"
  },
  {
    "question": "Which method is used to move ResultSet cursor to the next row?",
    "option1": "nextRow()",
    "option2": "move()",
    "option3": "next()",
    "option4": "shift()",
    "option5": "step()",
    "solution": "next()"
  },
  {
    "question": "Which SQLException method returns the error message?",
    "option1": "getMessage()",
    "option2": "getStack()",
    "option3": "getError()",
    "option4": "print()",
    "option5": "toString()",
    "solution": "getMessage()"
  },
  {
    "question": "JDBC drivers are loaded using:",
    "option1": "Class.forName()",
    "option2": "DriverManager.load()",
    "option3": "SQLDriver.start()",
    "option4": "Driver.loadClass()",
    "option5": "Driver.connect()",
    "solution": "Class.forName()"
  },

  {
    "question": "PreparedStatement is used for:",
    "option1": "Precompiled SQL queries",
    "option2": "Table creation only",
    "option3": "Update only",
    "option4": "Database connection",
    "option5": "Schema reading",
    "solution": "Precompiled SQL queries"
  },
  {
    "question": "Which method is used to insert/update/delete records?",
    "option1": "executeQuery()",
    "option2": "runUpdate()",
    "option3": "executeUpdate()",
    "option4": "write()",
    "option5": "executeWrite()",
    "solution": "executeUpdate()"
  },
  {
    "question": "Which ResultSet type allows backward scrolling?",
    "option1": "TYPE_SCROLL_INSENSITIVE",
    "option2": "TYPE_FORWARD_ONLY",
    "option3": "TYPE_STATIC",
    "option4": "TYPE_LOCKED",
    "option5": "TYPE_BUFFERED",
    "solution": "TYPE_SCROLL_INSENSITIVE"
  },
  {
    "question": "What does ResultSet.next() return?",
    "option1": "An integer",
    "option2": "A boolean",
    "option3": "A String",
    "option4": "A row object",
    "option5": "An index",
    "solution": "A boolean"
  },
  {
    "question": "Which SQL exception class handles batch update errors?",
    "option1": "SQLTimeoutException",
    "option2": "SQLDataException",
    "option3": "BatchUpdateException",
    "option4": "SQLWarning",
    "option5": "SQLSyntaxError",
    "solution": "BatchUpdateException"
  },
  {
    "question": "Which interface is used for calling stored procedures?",
    "option1": "PreparedStatement",
    "option2": "CallableStatement",
    "option3": "ProcedureExecutor",
    "option4": "FunctionCall",
    "option5": "Statement",
    "solution": "CallableStatement"
  },
  {
    "question": "Which property enables transactions in JDBC?",
    "option1": "setAutoCommit(false)",
    "option2": "enableTransaction()",
    "option3": "begin()",
    "option4": "connection.transactionOn()",
    "option5": "setCommitMode()",
    "solution": "setAutoCommit(false)"
  },
  {
    "question": "Which method commits transactions?",
    "option1": "apply()",
    "option2": "save()",
    "option3": "commit()",
    "option4": "finish()",
    "option5": "complete()",
    "solution": "commit()"
  },
  {
    "question": "Which ResultSet method sets cursor to the first row?",
    "option1": "start()",
    "option2": "moveTo()",
    "option3": "first()",
    "option4": "goto()",
    "option5": "begin()",
    "solution": "first()"
  },
  {
    "question": "Which method closes a JDBC connection?",
    "option1": "disconnect()",
    "option2": "stop()",
    "option3": "close()",
    "option4": "kill()",
    "option5": "exit()",
    "solution": "close()"
  },

  {
    "question": "JDBC follows which architecture?",
    "option1": "Driver Manager architecture",
    "option2": "Proxy architecture",
    "option3": "Kernel-driver architecture",
    "option4": "JVM plug-in architecture",
    "option5": "Relational architecture",
    "solution": "Driver Manager architecture"
  },
  {
    "question": "Which JDBC driver type uses native API and converts calls into database API calls?",
    "option1": "Type 4",
    "option2": "Type 1",
    "option3": "Type 2",
    "option4": "Type 3",
    "option5": "Type 5",
    "solution": "Type 2"
  },
  {
    "question": "Which driver uses pure Java with no native libraries?",
    "option1": "Type 2",
    "option2": "Type 1",
    "option3": "Type 4",
    "option4": "Type 5",
    "option5": "Type 3",
    "solution": "Type 4"
  },
  {
    "question": "Which method of PreparedStatement sets string values?",
    "option1": "assignString()",
    "option2": "putString()",
    "option3": "setString()",
    "option4": "addString()",
    "option5": "writeString()",
    "solution": "setString()"
  },
  {
    "question": "Which SQLException method returns vendor-specific error code?",
    "option1": "getCode()",
    "option2": "getErrorCode()",
    "option3": "errorCode()",
    "option4": "sqlError()",
    "option5": "getVendor()",
    "solution": "getErrorCode()"
  },
  {
    "question": "Which ResultSet method checks for NULL values?",
    "option1": "wasNull()",
    "option2": "isNull()",
    "option3": "checkNull()",
    "option4": "nullCheck()",
    "option5": "validateNull()",
    "solution": "wasNull()"
  },
  {
    "question": "Scrollable ResultSet allows:",
    "option1": "Forward only",
    "option2": "Backward only",
    "option3": "Forward and backward movement",
    "option4": "Random writing",
    "option5": "Column editing",
    "solution": "Forward and backward movement"
  },
  {
    "question": "Which operation is NOT allowed in read-only ResultSet?",
    "option1": "Deleting rows",
    "option2": "Scrolling",
    "option3": "Reading values",
    "option4": "Moving cursor",
    "option5": "Accessing metadata",
    "solution": "Deleting rows"
  },
  {
    "question": "Which class provides metadata of ResultSet?",
    "option1": "SQLMeta",
    "option2": "ResultMeta",
    "option3": "ResultSetMetaData",
    "option4": "TableMeta",
    "option5": "MetaDataSQL",
    "solution": "ResultSetMetaData"
  },
  {
    "question": "Which object is used for batch operations?",
    "option1": "BatchRunner",
    "option2": "BatchSet",
    "option3": "Statement",
    "option4": "BatchManager",
    "option5": "ResultSet",
    "solution": "Statement"
  },
  {
    "question": "Which method adds SQL commands to a batch?",
    "option1": "add()",
    "option2": "append()",
    "option3": "addBatch()",
    "option4": "pushBatch()",
    "option5": "insertBatch()",
    "solution": "addBatch()"
  },
  {
    "question": "Which interface handles transactions?",
    "option1": "Connection",
    "option2": "Statement",
    "option3": "SQLExecutor",
    "option4": "DBManager",
    "option5": "TransactionManager",
    "solution": "Connection"
  },

  {
    "question": "Hard: Which JDBC method rolls back a transaction?",
    "option1": "withdraw()",
    "option2": "rollback()",
    "option3": "undo()",
    "option4": "reverse()",
    "option5": "cancelTX()",
    "solution": "rollback()"
  },
  {
    "question": "Hard: Type 3 driver communicates with DB using:",
    "option1": "Middleware server",
    "option2": "Native binary",
    "option3": "ODBC layer",
    "option4": "JNI wrapper",
    "option5": "TCP stack",
    "solution": "Middleware server"
  },
  {
    "question": "Hard: Which API allows reading large binary data?",
    "option1": "getBytes()",
    "option2": "getBlob()",
    "option3": "getBinary()",
    "option4": "getRaw()",
    "option5": "getStream()",
    "solution": "getBlob()"
  },
  {
    "question": "Hard: What does this code print?\nConnection c=null; try{c.close();}catch(Exception e){System.out.println(\"X\");}",
    "option1": "null",
    "option2": "X",
    "option3": "close",
    "option4": "error",
    "option5": "Nothing printed",
    "solution": "X"
  },
  {
    "question": "Hard: What happens if executeQuery() is used for INSERT?",
    "option1": "SQLException is thrown",
    "option2": "Row inserted",
    "option3": "Returns ResultSet",
    "option4": "Auto-commit stops",
    "option5": "Nothing happens",
    "solution": "SQLException is thrown"
  },
  {
    "question": "Hard: Which method retrieves column count?",
    "option1": "getColumnNumber()",
    "option2": "getCount()",
    "option3": "getColumnCount()",
    "option4": "columnSize()",
    "option5": "metaCount()",
    "solution": "getColumnCount()"
  },
  {
    "question": "Hard: Which JDBC feature maps rows to Java objects?",
    "option1": "RowMapper",
    "option2": "ObjectMap",
    "option3": "ORMMapper",
    "option4": "JDBCBinder",
    "option5": "ResultMapper",
    "solution": "RowMapper"
  },
  {
    "question": "Hard: What does setFetchSize() improve?",
    "option1": "Query caching",
    "option2": "Row prefetching performance",
    "option3": "Indexing speed",
    "option4": "Schema rebuilding",
    "option5": "Column encryption",
    "solution": "Row prefetching performance"
  },
  {
    "question": "Hard coding: Identify the output:\nResultSet rs=null; if(rs==null) System.out.println(\"A\");",
    "option1": "NullPointerException",
    "option2": "A",
    "option3": "Error",
    "option4": "No output",
    "option5": "False",
    "solution": "A"
  },
  {
    "question": "Hard: Which statement is TRUE about Connection pooling?",
    "option1": "It reuses DB connections to improve performance",
    "option2": "It reduces SQL size",
    "option3": "It makes ResultSet scrollable",
    "option4": "It performs auto-commit always",
    "option5": "It removes need for drivers",
    "solution": "It reuses DB connections to improve performance"
  }
]
