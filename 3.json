[
  {
    "question": "RMI stands for:",
    "option1": "Remote Method Invocation",
    "option2": "Remote Machine Interface",
    "option3": "Remote Meta Interaction",
    "option4": "Remote Messaging Interface",
    "option5": "Remote Method Interface",
    "solution": "Remote Method Invocation"
  },
  {
    "question": "Java RMI is used for:",
    "option1": "Calling remote methods on distributed objects",
    "option2": "Encrypting remote data",
    "option3": "Running threads remotely",
    "option4": "Local process creation",
    "option5": "Hardware remote access",
    "solution": "Calling remote methods on distributed objects"
  },
  {
    "question": "Which package contains RMI classes?",
    "option1": "java.remote",
    "option2": "javax.rmi",
    "option3": "java.rmi",
    "option4": "remote.java",
    "option5": "rmi.remote",
    "solution": "java.rmi"
  },
  {
    "question": "Which interface must remote objects implement?",
    "option1": "RemoteInterface",
    "option2": "Serializable",
    "option3": "Remote",
    "option4": "Runnable",
    "option5": "Distributed",
    "solution": "Remote"
  },
  {
    "question": "A remote method must declare which exception?",
    "option1": "IOException",
    "option2": "RemoteException",
    "option3": "SQLException",
    "option4": "ServerException",
    "option5": "NetworkException",
    "solution": "RemoteException"
  },
  {
    "question": "Which class is used to export remote objects?",
    "option1": "UnicastRemoteObject",
    "option2": "RemoteServer",
    "option3": "RemoteObject",
    "option4": "ServerExport",
    "option5": "RMIExporter",
    "solution": "UnicastRemoteObject"
  },
  {
    "question": "The registry lookup uses which class?",
    "option1": "RMIRegistry",
    "option2": "Naming",
    "option3": "Locate",
    "option4": "RemoteFinder",
    "option5": "Registry",
    "solution": "Naming"
  },
  {
    "question": "Which tool was used in older RMI versions to generate stubs?",
    "option1": "rmic",
    "option2": "rmigen",
    "option3": "javac-rmi",
    "option4": "stubgen",
    "option5": "objremote",
    "solution": "rmic"
  },
  {
    "question": "RMI uses which protocol by default?",
    "option1": "HTTP",
    "option2": "TCP/IP",
    "option3": "UDP",
    "option4": "SMTP",
    "option5": "RUDP",
    "solution": "TCP/IP"
  },
  {
    "question": "Remote objects must be:",
    "option1": "Serialized",
    "option2": "Compiled in C",
    "option3": "Static",
    "option4": "Synchronized",
    "option5": "Atomic",
    "solution": "Serialized"
  },

  {
    "question": "Which method binds a name to a remote object?",
    "option1": "Naming.save()",
    "option2": "Naming.lookup()",
    "option3": "Naming.bind()",
    "option4": "Naming.add()",
    "option5": "Registry.save()",
    "solution": "Naming.bind()"
  },
  {
    "question": "Which is NOT required for RMI?",
    "option1": "Remote interface",
    "option2": "Remote implementation",
    "option3": "RMI registry",
    "option4": "Database server",
    "option5": "Stub",
    "solution": "Database server"
  },
  {
    "question": "Which class starts the RMI registry programmatically?",
    "option1": "LocateRegistry",
    "option2": "Naming",
    "option3": "RegistryBuilder",
    "option4": "RMIServer",
    "option5": "RMIBridge",
    "solution": "LocateRegistry"
  },
  {
    "question": "RMI follows which model?",
    "option1": "Object-based distributed model",
    "option2": "Thread-pooling model",
    "option3": "Client-stream model",
    "option4": "Pipeline model",
    "option5": "Event-driven model",
    "solution": "Object-based distributed model"
  },
  {
    "question": "Which port does the RMI registry use by default?",
    "option1": "1521",
    "option2": "1099",
    "option3": "8080",
    "option4": "1433",
    "option5": "3306",
    "solution": "1099"
  },
  {
    "question": "Which keyword is used to mark a remote interface?",
    "option1": "implements Remote",
    "option2": "remote class",
    "option3": "extends RMI",
    "option4": "rmi object",
    "option5": "implements Distributed",
    "solution": "implements Remote"
  },
  {
    "question": "Which exception indicates network failure?",
    "option1": "RemoteException",
    "option2": "IOException",
    "option3": "SQLException",
    "option4": "InterruptedException",
    "option5": "ClassNotFoundException",
    "solution": "RemoteException"
  },
  {
    "question": "Which is required for RMI communication?",
    "option1": "Security manager",
    "option2": "HTTP server",
    "option3": "Apache Tomcat",
    "option4": "XML parser",
    "option5": "FTP server",
    "solution": "Security manager"
  },
  {
    "question": "Stub acts as:",
    "option1": "Client-side proxy",
    "option2": "Database connector",
    "option3": "Server mapper",
    "option4": "Thread manager",
    "option5": "Serialization handler",
    "solution": "Client-side proxy"
  },
  {
    "question": "Skeleton acts as:",
    "option1": "Server-side dispatcher",
    "option2": "Client proxy",
    "option3": "Network encryptor",
    "option4": "Object pool",
    "option5": "Compiler",
    "solution": "Server-side dispatcher"
  },

  {
    "question": "Which can dynamically generate stubs since Java 5?",
    "option1": "Proxy API",
    "option2": "RMI Generator",
    "option3": "rmic tool",
    "option4": "java.stub",
    "option5": "DynamicBinder",
    "solution": "Proxy API"
  },
  {
    "question": "Which method registers an object in registry?",
    "option1": "rebind()",
    "option2": "lookup()",
    "option3": "connect()",
    "option4": "assign()",
    "option5": "registry()",
    "solution": "rebind()"
  },
  {
    "question": "Which of the following is a remote reference layer?",
    "option1": "RRL",
    "option2": "Transport",
    "option3": "Stub",
    "option4": "Naming",
    "option5": "Registry",
    "solution": "Transport"
  },
  {
    "question": "RMI follows which architecture?",
    "option1": "Three-layer architecture",
    "option2": "Two-layer architecture",
    "option3": "Single-layer architecture",
    "option4": "Pipeline architecture",
    "option5": "Query-based architecture",
    "solution": "Three-layer architecture"
  },
  {
    "question": "Which remote method call step occurs FIRST?",
    "option1": "Network serialization",
    "option2": "Stub invocation",
    "option3": "Registry lookup",
    "option4": "Skeleton mapping",
    "option5": "Object reflection",
    "solution": "Registry lookup"
  },
  {
    "question": "Which layer handles marshalling?",
    "option1": "Transport layer",
    "option2": "Registry layer",
    "option3": "Stub layer",
    "option4": "Naming layer",
    "option5": "Serialization layer",
    "solution": "Stub layer"
  },
  {
    "question": "Which interface allows creating remote registry?",
    "option1": "Connector",
    "option2": "Registry",
    "option3": "RMIRegistry",
    "option4": "NamingRegistry",
    "option5": "PortBinder",
    "solution": "Registry"
  },
  {
    "question": "Which class provides factory methods for RMI registry?",
    "option1": "RMIServer",
    "option2": "RemoteFactory",
    "option3": "LocateRegistry",
    "option4": "RegistryBuilder",
    "option5": "ServerLocator",
    "solution": "LocateRegistry"
  },
  {
    "question": "Which return type is allowed for remote methods?",
    "option1": "Any serializable object",
    "option2": "Only primitive types",
    "option3": "Only Strings",
    "option4": "Only arrays",
    "option5": "Only Numbers",
    "solution": "Any serializable object"
  },
  {
    "question": "Which remote method is CORRECT?",
    "option1": "void run();",
    "option2": "String info() throws RemoteException;",
    "option3": "int add();",
    "option4": "void do() throw IOException;",
    "option5": "void remote();",
    "solution": "String info() throws RemoteException;"
  },
  {
    "question": "Which correctly looks up registry?",
    "option1": "Naming.lookup(\"rmi://localhost/obj\")",
    "option2": "Registry.find(\"obj\")",
    "option3": "Lookup.get(\"rmi\")",
    "option4": "Remote.get(\"obj\")",
    "option5": "Locate.find(\"obj\")",
    "solution": "Naming.lookup(\"rmi://localhost/obj\")"
  },
  {
    "question": "Which method unbinds an object?",
    "option1": "Naming.remove()",
    "option2": "Naming.delete()",
    "option3": "Naming.unbind()",
    "option4": "Naming.clear()",
    "option5": "Registry.remove()",
    "solution": "Naming.unbind()"
  },
  {
    "question": "What is transported over the network in RMI?",
    "option1": "Method references only",
    "option2": "Object code",
    "option3": "Serialized parameters and results",
    "option4": "Class definitions",
    "option5": "Registry values",
    "solution": "Serialized parameters and results"
  },
  {
    "question": "What is the major advantage of RMI?",
    "option1": "Platform independence for distributed computing",
    "option2": "Faster GUI rendering",
    "option3": "Better file compression",
    "option4": "Improved security",
    "option5": "Database caching",
    "solution": "Platform independence for distributed computing"
  },

  {
    "question": "Hard: What will this code do?\nRemote obj = Naming.lookup(\"rmi://localhost/test\");",
    "option1": "Returns a stub object",
    "option2": "Starts server",
    "option3": "Balances threads",
    "option4": "Opens registry GUI",
    "option5": "Deletes remote object",
    "solution": "Returns a stub object"
  },
  {
    "question": "Hard: Which layer performs unmarshalling?",
    "option1": "Stub layer",
    "option2": "Skeleton layer",
    "option3": "Transport layer",
    "option4": "Registry layer",
    "option5": "Lookup layer",
    "solution": "Skeleton layer"
  },
  {
    "question": "Hard: Which method returns a reference to remote registry?",
    "option1": "LocateRegistry.getRegistry()",
    "option2": "Registry.call()",
    "option3": "RMI.get()",
    "option4": "RMIRegistry.open()",
    "option5": "Remote.find()",
    "solution": "LocateRegistry.getRegistry()"
  },
  {
    "question": "Hard: RMI uses which serialization mechanism?",
    "option1": "CORBA serialization",
    "option2": "Java Object Serialization",
    "option3": "Binary Compression",
    "option4": "JSON Serialization",
    "option5": "XML Marshalling",
    "solution": "Java Object Serialization"
  },
  {
    "question": "Hard: Which is a TRUE statement about stubs?",
    "option1": "They forward calls to skeleton",
    "option2": "They run only on server",
    "option3": "They generate objects",
    "option4": "They store registry",
    "option5": "They compile interfaces",
    "solution": "They forward calls to skeleton"
  },
  {
    "question": "Hard: RMI registry maps:",
    "option1": "Names to remote object references",
    "option2": "Ports to threads",
    "option3": "Classes to JVM",
    "option4": "Exceptions to handlers",
    "option5": "Sockets to connections",
    "solution": "Names to remote object references"
  },
  {
    "question": "Hard coding: Identify output:\nSystem.setProperty(\"java.rmi.server.hostname\", \"127.0.0.1\");",
    "option1": "Sets RMI server hostname",
    "option2": "Starts RMI registry",
    "option3": "Creates stub",
    "option4": "Throws exception",
    "option5": "Does nothing",
    "solution": "Sets RMI server hostname"
  },
  {
    "question": "Hard: Which class is extended to make a remote class?",
    "option1": "UnicastRemoteObject",
    "option2": "RemoteObject",
    "option3": "RMIBase",
    "option4": "RemoteServer",
    "option5": "Distributed",
    "solution": "UnicastRemoteObject"
  },
  {
    "question": "Hard: RMI remote method parameters must be:",
    "option1": "Serializable",
    "option2": "Thread-safe",
    "option3": "Primitive only",
    "option4": "Static",
    "option5": "Transient",
    "solution": "Serializable"
  },
  {
    "question": "Hard: What happens when server crashes during remote call?",
    "option1": "RemoteException",
    "option2": "NullPointerException",
    "option3": "SQL Error",
    "option4": "No output",
    "option5": "Shutdown event",
    "solution": "RemoteException"
  }
]
