[
  {
    "question": "RMI stands for:",
    "option1": "Remote Method Invocation",
    "option2": "Remote Machine Interface",
    "option3": "Remote Meta Interaction",
    "option4": "Remote Messaging Interface",
    "option5": "Remote Method Interface",
    "solution": "Remote Method Invocation"
  },
  {
    "question": "Java RMI is used for:",
    "option1": "Calling remote methods on distributed objects",
    "option2": "Encrypting remote data",
    "option3": "Running threads remotely",
    "option4": "Local process creation",
    "option5": "Hardware remote access",
    "solution": "Calling remote methods on distributed objects"
  },
  {
    "question": "Which package contains RMI classes?",
    "option1": "java.remote",
    "option2": "javax.rmi",
    "option3": "java.rmi",
    "option4": "remote.java",
    "option5": "rmi.remote",
    "solution": "java.rmi"
  },
  {
    "question": "Which interface must remote objects implement?",
    "option1": "RemoteInterface",
    "option2": "Serializable",
    "option3": "Remote",
    "option4": "Runnable",
    "option5": "Distributed",
    "solution": "Remote"
  },
  {
    "question": "A remote method must declare which exception?",
    "option1": "IOException",
    "option2": "RemoteException",
    "option3": "SQLException",
    "option4": "ServerException",
    "option5": "NetworkException",
    "solution": "RemoteException"
  },
  {
    "question": "Which class is used to export remote objects?",
    "option1": "UnicastRemoteObject",
    "option2": "RemoteServer",
    "option3": "RemoteObject",
    "option4": "ServerExport",
    "option5": "RMIExporter",
    "solution": "UnicastRemoteObject"
  },
  {
    "question": "The registry lookup uses which class?",
    "option1": "RMIRegistry",
    "option2": "Naming",
    "option3": "Locate",
    "option4": "RemoteFinder",
    "option5": "Registry",
    "solution": "Naming"
  },
  {
    "question": "Which tool was used in older RMI versions to generate stubs?",
    "option1": "rmic",
    "option2": "rmigen",
    "option3": "javac-rmi",
    "option4": "stubgen",
    "option5": "objremote",
    "solution": "rmic"
  },
  {
    "question": "RMI uses which protocol by default?",
    "option1": "HTTP",
    "option2": "TCP/IP",
    "option3": "UDP",
    "option4": "SMTP",
    "option5": "RUDP",
    "solution": "TCP/IP"
  },
  {
    "question": "Remote objects must be:",
    "option1": "Serialized",
    "option2": "Compiled in C",
    "option3": "Static",
    "option4": "Synchronized",
    "option5": "Atomic",
    "solution": "Serialized"
  },

  {
    "question": "Which method binds a name to a remote object?",
    "option1": "Naming.save()",
    "option2": "Naming.lookup()",
    "option3": "Naming.bind()",
    "option4": "Naming.add()",
    "option5": "Registry.save()",
    "solution": "Naming.bind()"
  },
  {
    "question": "Which is NOT required for RMI?",
    "option1": "Remote interface",
    "option2": "Remote implementation",
    "option3": "RMI registry",
    "option4": "Database server",
    "option5": "Stub",
    "solution": "Database server"
  },
  {
    "question": "Which class starts the RMI registry programmatically?",
    "option1": "LocateRegistry",
    "option2": "Naming",
    "option3": "RegistryBuilder",
    "option4": "RMIServer",
    "option5": "RMIBridge",
    "solution": "LocateRegistry"
  },
  {
    "question": "RMI follows which model?",
    "option1": "Object-based distributed model",
    "option2": "Thread-pooling model",
    "option3": "Client-stream model",
    "option4": "Pipeline model",
    "option5": "Event-driven model",
    "solution": "Object-based distributed model"
  },
  {
    "question": "Which port does the RMI registry use by default?",
    "option1": "1521",
    "option2": "1099",
    "option3": "8080",
    "option4": "1433",
    "option5": "3306",
    "solution": "1099"
  },
  {
    "question": "Which keyword is used to mark a remote interface?",
    "option1": "implements Remote",
    "option2": "remote class",
    "option3": "extends RMI",
    "option4": "rmi object",
    "option5": "implements Distributed",
    "solution": "implements Remote"
  },
  {
    "question": "Which exception indicates network failure?",
    "option1": "RemoteException",
    "option2": "IOException",
    "option3": "SQLException",
    "option4": "InterruptedException",
    "option5": "ClassNotFoundException",
    "solution": "RemoteException"
  },
  {
    "question": "Which is required for RMI communication?",
    "option1": "Security manager",
    "option2": "HTTP server",
    "option3": "Apache Tomcat",
    "option4": "XML parser",
    "option5": "FTP server",
    "solution": "Security manager"
  },
  {
    "question": "Stub acts as:",
    "option1": "Client-side proxy",
    "option2": "Database connector",
    "option3": "Server mapper",
    "option4": "Thread manager",
    "option5": "Serialization handler",
    "solution": "Client-side proxy"
  },
  {
    "question": "Skeleton acts as:",
    "option1": "Server-side dispatcher",
    "option2": "Client proxy",
    "option3": "Network encryptor",
    "option4": "Object pool",
    "option5": "Compiler",
    "solution": "Server-side dispatcher"
  },

  {
    "question": "Which can dynamically generate stubs since Java 5?",
    "option1": "Proxy API",
    "option2": "RMI Generator",
    "option3": "rmic tool",
    "option4": "java.stub",
    "option5": "DynamicBinder",
    "solution": "Proxy API"
  },
  {
    "question": "Which method registers an object in registry?",
    "option1": "rebind()",
    "option2": "lookup()",
    "option3": "connect()",
    "option4": "assign()",
    "option5": "registry()",
    "solution": "rebind()"
  },
  {
    "question": "Which of the following is a remote reference layer?",
    "option1": "RRL",
    "option2": "Transport",
    "option3": "Stub",
    "option4": "Naming",
    "option5": "Registry",
    "solution": "Transport"
  },
  {
    "question": "RMI follows which architecture?",
    "option1": "Three-layer architecture",
    "option2": "Two-layer architecture",
    "option3": "Single-layer architecture",
    "option4": "Pipeline architecture",
    "option5": "Query-based architecture",
    "solution": "Three-layer architecture"
  },
  {
    "question": "Which remote method call step occurs FIRST?",
    "option1": "Network serialization",
    "option2": "Stub invocation",
    "option3": "Registry lookup",
    "option4": "Skeleton mapping",
    "option5": "Object reflection",
    "solution": "Registry lookup"
  },
  {
    "question": "Which layer handles marshalling?",
    "option1": "Transport layer",
    "option2": "Registry layer",
    "option3": "Stub layer",
    "option4": "Naming layer",
    "option5": "Serialization layer",
    "solution": "Stub layer"
  },
  {
    "question": "Which interface allows creating remote registry?",
    "option1": "Connector",
    "option2": "Registry",
    "option3": "RMIRegistry",
    "option4": "NamingRegistry",
    "option5": "PortBinder",
    "solution": "Registry"
  },
  {
    "question": "Which class provides factory methods for RMI registry?",
    "option1": "RMIServer",
    "option2": "RemoteFactory",
    "option3": "LocateRegistry",
    "option4": "RegistryBuilder",
    "option5": "ServerLocator",
    "solution": "LocateRegistry"
  },
  {
    "question": "Which return type is allowed for remote methods?",
    "option1": "Any serializable object",
    "option2": "Only primitive types",
    "option3": "Only Strings",
    "option4": "Only arrays",
    "option5": "Only Numbers",
    "solution": "Any serializable object"
  },
  {
    "question": "Which remote method is CORRECT?",
    "option1": "void run();",
    "option2": "String info() throws RemoteException;",
    "option3": "int add();",
    "option4": "void do() throw IOException;",
    "option5": "void remote();",
    "solution": "String info() throws RemoteException;"
  },
  {
    "question": "Which correctly looks up registry?",
    "option1": "Naming.lookup(\"rmi://localhost/obj\")",
    "option2": "Registry.find(\"obj\")",
    "option3": "Lookup.get(\"rmi\")",
    "option4": "Remote.get(\"obj\")",
    "option5": "Locate.find(\"obj\")",
    "solution": "Naming.lookup(\"rmi://localhost/obj\")"
  },
  {
    "question": "Which method unbinds an object?",
    "option1": "Naming.remove()",
    "option2": "Naming.delete()",
    "option3": "Naming.unbind()",
    "option4": "Naming.clear()",
    "option5": "Registry.remove()",
    "solution": "Naming.unbind()"
  },
  {
    "question": "What is transported over the network in RMI?",
    "option1": "Method references only",
    "option2": "Object code",
    "option3": "Serialized parameters and results",
    "option4": "Class definitions",
    "option5": "Registry values",
    "solution": "Serialized parameters and results"
  },
  {
    "question": "What is the major advantage of RMI?",
    "option1": "Platform independence for distributed computing",
    "option2": "Faster GUI rendering",
    "option3": "Better file compression",
    "option4": "Improved security",
    "option5": "Database caching",
    "solution": "Platform independence for distributed computing"
  },

  {
    "question": "Hard: What will this code do?\nRemote obj = Naming.lookup(\"rmi://localhost/test\");",
    "option1": "Returns a stub object",
    "option2": "Starts server",
    "option3": "Balances threads",
    "option4": "Opens registry GUI",
    "option5": "Deletes remote object",
    "solution": "Returns a stub object"
  },
  {
    "question": "Hard: Which layer performs unmarshalling?",
    "option1": "Stub layer",
    "option2": "Skeleton layer",
    "option3": "Transport layer",
    "option4": "Registry layer",
    "option5": "Lookup layer",
    "solution": "Skeleton layer"
  },
  {
    "question": "Hard: Which method returns a reference to remote registry?",
    "option1": "LocateRegistry.getRegistry()",
    "option2": "Registry.call()",
    "option3": "RMI.get()",
    "option4": "RMIRegistry.open()",
    "option5": "Remote.find()",
    "solution": "LocateRegistry.getRegistry()"
  },
  {
    "question": "Hard: RMI uses which serialization mechanism?",
    "option1": "CORBA serialization",
    "option2": "Java Object Serialization",
    "option3": "Binary Compression",
    "option4": "JSON Serialization",
    "option5": "XML Marshalling",
    "solution": "Java Object Serialization"
  },
  {
    "question": "Hard: Which is a TRUE statement about stubs?",
    "option1": "They forward calls to skeleton",
    "option2": "They run only on server",
    "option3": "They generate objects",
    "option4": "They store registry",
    "option5": "They compile interfaces",
    "solution": "They forward calls to skeleton"
  },
  {
    "question": "Hard: RMI registry maps:",
    "option1": "Names to remote object references",
    "option2": "Ports to threads",
    "option3": "Classes to JVM",
    "option4": "Exceptions to handlers",
    "option5": "Sockets to connections",
    "solution": "Names to remote object references"
  },
  {
    "question": "Hard coding: Identify output:\nSystem.setProperty(\"java.rmi.server.hostname\", \"127.0.0.1\");",
    "option1": "Sets RMI server hostname",
    "option2": "Starts RMI registry",
    "option3": "Creates stub",
    "option4": "Throws exception",
    "option5": "Does nothing",
    "solution": "Sets RMI server hostname"
  },
  {
    "question": "Hard: Which class is extended to make a remote class?",
    "option1": "UnicastRemoteObject",
    "option2": "RemoteObject",
    "option3": "RMIBase",
    "option4": "RemoteServer",
    "option5": "Distributed",
    "solution": "UnicastRemoteObject"
  },
  {
    "question": "Hard: RMI remote method parameters must be:",
    "option1": "Serializable",
    "option2": "Thread-safe",
    "option3": "Primitive only",
    "option4": "Static",
    "option5": "Transient",
    "solution": "Serializable"
  },
  {
    "question": "Hard: What happens when server crashes during remote call?",
    "option1": "RemoteException",
    "option2": "NullPointerException",
    "option3": "SQL Error",
    "option4": "No output",
    "option5": "Shutdown event",
    "solution": "RemoteException"
  },
  {
    "question": "Distributed Object Technology, as discussed in the RMI section, mainly aims to:",
    "option1": "Allow objects located on different machines to interact as if local",
    "option2": "Compress objects in memory",
    "option3": "Encrypt files on disk",
    "option4": "Speed up Swing GUIs",
    "option5": "Replace JDBC drivers",
    "solution": "Allow objects located on different machines to interact as if local"
  },
  {
    "question": "In a typical RMI client-server example with two numbers, what is the usual role of the remote method?",
    "option1": "Return the sum of numbers only",
    "option2": "Return the smaller number only",
    "option3": "Return the bigger number to the client",
    "option4": "Return both numbers unmodified",
    "option5": "Store numbers in a database",
    "solution": "Return the bigger number to the client"
  },
  {
    "question": "In RMI client/server example where client sends 10 numbers and server returns counts of even and odd numbers, which side typically hosts the remote object?",
    "option1": "Client",
    "option2": "Server",
    "option3": "Both client and server simultaneously",
    "option4": "Database machine",
    "option5": "Web browser",
    "solution": "Server"
  },
  {
    "question": "In RMI architecture questions, which component holds the mapping from a name to a remote object reference?",
    "option1": "Stub",
    "option2": "rmiregistry",
    "option3": "Skeleton",
    "option4": "Servlet container",
    "option5": "JDBC driver",
    "solution": "rmiregistry"
  },
  {
    "question": "Which interface must every remote interface extend in Java RMI?",
    "option1": "Serializable",
    "option2": "Remote",
    "option3": "Runnable",
    "option4": "Cloneable",
    "option5": "Comparable",
    "solution": "Remote"
  },
  {
    "question": "In RMI, the client obtains a stub reference to the remote object typically by calling:",
    "option1": "Naming.bind()",
    "option2": "Naming.lookup()",
    "option3": "Remote.getObject()",
    "option4": "Registry.register()",
    "option5": "RMI.start()",
    "solution": "Naming.lookup()"
  },
  {
    "question": "What is the role of rmiregistry in an RMI application?",
    "option1": "To store SQL queries",
    "option2": "To store remote object references bound to names",
    "option3": "To compile remote interfaces",
    "option4": "To encrypt remote communication",
    "option5": "To handle Swing events remotely",
    "solution": "To store remote object references bound to names"
  },
  {
    "question": "In the RMI string-processing example (remove extra spaces then reverse), which of these is the most likely remote method signature?",
    "option1": "public void process(String s) throws SQLException;",
    "option2": "public int process(int a, int b) throws RemoteException;",
    "option3": "public String process(String s) throws RemoteException;",
    "option4": "public String[] process(String[] s) throws IOException;",
    "option5": "public void process() throws RemoteException;",
    "solution": "public String process(String s) throws RemoteException;"
  },
  {
    "question": "Which pair correctly matches responsibility in RMI architecture?",
    "option1": "Stub – server-side dispatcher; Skeleton – client proxy",
    "option2": "Stub – client proxy; Skeleton – server-side dispatcher",
    "option3": "Stub – database connector; Skeleton – GUI builder",
    "option4": "Stub – exception logger; Skeleton – RMI registry",
    "option5": "Stub – thread manager; Skeleton – serializer",
    "solution": "Stub – client proxy; Skeleton – server-side dispatcher"
  },
  {
    "question": "One key benefit of distributed object technologies (like RMI) is:",
    "option1": "They eliminate network communication",
    "option2": "They allow methods of remote objects to be invoked as if local",
    "option3": "They remove the need for interfaces",
    "option4": "They run only on a single JVM",
    "option5": "They replace all socket handling in Java",
    "solution": "They allow methods of remote objects to be invoked as if local"
  }
]

