[
  {
    "question": "Which class is the superclass of all Swing components?",
    "option1": "Component",
    "option2": "JComponent",
    "option3": "Object",
    "option4": "AWTComponent",
    "option5": "SwingBase",
    "solution": "JComponent"
  },
  {
    "question": "Swing is built on top of which older GUI framework?",
    "option1": "GTK",
    "option2": "AWT",
    "option3": "JavaFX",
    "option4": "SWT",
    "option5": "WinForms",
    "solution": "AWT"
  },
  {
    "question": "Swing components are considered:",
    "option1": "Heavyweight",
    "option2": "Kernel-based",
    "option3": "Lightweight",
    "option4": "Native-only",
    "option5": "Hardware-accelerated",
    "solution": "Lightweight"
  },
  {
    "question": "Which Swing class creates a clickable button?",
    "option1": "Button",
    "option2": "JToggle",
    "option3": "JPress",
    "option4": "JButton",
    "option5": "JAction",
    "solution": "JButton"
  },
  {
    "question": "Which component is commonly used to group multiple Swing components?",
    "option1": "JList",
    "option2": "JPanel",
    "option3": "JFrame",
    "option4": "JDialog",
    "option5": "JSplitPane",
    "solution": "JPanel"
  },
  {
    "question": "A top-level Swing container is:",
    "option1": "JLabel",
    "option2": "JFrame",
    "option3": "JButton",
    "option4": "JMenuItem",
    "option5": "JPanel",
    "solution": "JFrame"
  },
  {
    "question": "Swing is located in which Java package?",
    "option1": "java.ui.swing",
    "option2": "javax.swing",
    "option3": "java.swing",
    "option4": "javax.ui",
    "option5": "java.awt",
    "solution": "javax.swing"
  },
  {
    "question": "Which layout manager arranges items in a single row or column?",
    "option1": "FlowLayout",
    "option2": "BorderLayout",
    "option3": "BoxLayout",
    "option4": "GridLayout",
    "option5": "CardLayout",
    "solution": "BoxLayout"
  },
  {
    "question": "Which Swing component displays a list of items?",
    "option1": "JMenu",
    "option2": "JTable",
    "option3": "JList",
    "option4": "JPanel",
    "option5": "JToolBar",
    "solution": "JList"
  },
  {
    "question": "Which is NOT a Swing container?",
    "option1": "JPanel",
    "option2": "JFrame",
    "option3": "JDialog",
    "option4": "JTable",
    "option5": "JWindow",
    "solution": "JTable"
  },

  {
    "question": "Which method displays a JFrame?",
    "option1": "show()",
    "option2": "reveal()",
    "option3": "setVisible(true)",
    "option4": "displayFrame()",
    "option5": "open()",
    "solution": "setVisible(true)"
  },
  {
    "question": "Which Swing class provides tabular data visualization?",
    "option1": "JTree",
    "option2": "JTable",
    "option3": "JPanel",
    "option4": "JLabel",
    "option5": "JMenu",
    "solution": "JTable"
  },
  {
    "question": "Which dialog type shows simple alert messages?",
    "option1": "JDialog",
    "option2": "JOptionPane.showMessageDialog",
    "option3": "JTextDialog",
    "option4": "JWarningBox",
    "option5": "JWindow",
    "solution": "JOptionPane.showMessageDialog"
  },
  {
    "question": "Which component adds scrollbars around another component?",
    "option1": "JScrollPane",
    "option2": "JTrackBar",
    "option3": "JScrollView",
    "option4": "JSlider",
    "option5": "JViewport",
    "solution": "JScrollPane"
  },
  {
    "question": "Which event listener handles button clicks?",
    "option1": "MouseListener",
    "option2": "KeyListener",
    "option3": "ActionListener",
    "option4": "WindowListener",
    "option5": "FocusListener",
    "solution": "ActionListener"
  },
  {
    "question": "Swing's event mechanism is based on:",
    "option1": "Polling",
    "option2": "Interrupts",
    "option3": "Delegation event model",
    "option4": "Listener threads",
    "option5": "Rendering cycles",
    "solution": "Delegation event model"
  },
  {
    "question": "Which component is used for hierarchical data?",
    "option1": "JTree",
    "option2": "JLabel",
    "option3": "JPanel",
    "option4": "JList",
    "option5": "JGrid",
    "solution": "JTree"
  },
  {
    "question": "Which component gives slider functionality?",
    "option1": "JSlider",
    "option2": "JLevel",
    "option3": "JBar",
    "option4": "JScrollBar",
    "option5": "JRotate",
    "solution": "JSlider"
  },
  {
    "question": "Which component represents a progress indicator?",
    "option1": "JSlider",
    "option2": "JProgressBar",
    "option3": "JLoadBar",
    "option4": "JStatus",
    "option5": "JMonitor",
    "solution": "JProgressBar"
  },
  {
    "question": "Swing components should be updated only on:",
    "option1": "Main thread",
    "option2": "AWT thread",
    "option3": "Event Dispatch Thread",
    "option4": "Worker thread",
    "option5": "Network thread",
    "solution": "Event Dispatch Thread"
  },

  {
    "question": "Which code correctly adds a JButton to a JFrame?",
    "option1": "f.attach(new JButton(\"OK\"));",
    "option2": "f.insert(btn);",
    "option3": "f.add(new JButton(\"OK\"));",
    "option4": "f.put(btn);",
    "option5": "f.push(btn);",
    "solution": "f.add(new JButton(\"OK\"));"
  },
  {
    "question": "Which layout arranges components sequentially left to right?",
    "option1": "BorderLayout",
    "option2": "GridLayout",
    "option3": "FlowLayout",
    "option4": "BoxLayout",
    "option5": "CardLayout",
    "solution": "FlowLayout"
  },
  {
    "question": "Which component allows only one item to be selected at a time?",
    "option1": "JCheckBox",
    "option2": "JButton",
    "option3": "JRadioButton",
    "option4": "JList",
    "option5": "JTextField",
    "solution": "JRadioButton"
  },
  {
    "question": "Which class groups multiple radio buttons?",
    "option1": "ButtonGroup",
    "option2": "JGroup",
    "option3": "JPanel",
    "option4": "JBox",
    "option5": "GridGroup",
    "solution": "ButtonGroup"
  },
  {
    "question": "Which layout divides window into 5 regions?",
    "option1": "GridLayout",
    "option2": "FlowLayout",
    "option3": "CardLayout",
    "option4": "BorderLayout",
    "option5": "StackLayout",
    "solution": "BorderLayout"
  },
  {
    "question": "Which method triggers redraw of a Swing component?",
    "option1": "repaint()",
    "option2": "updateUI()",
    "option3": "refresh()",
    "option4": "paint()",
    "option5": "render()",
    "solution": "repaint()"
  },
  {
    "question": "Which event occurs when a user presses a key?",
    "option1": "keyPressed",
    "option2": "keyDown",
    "option3": "keyStart",
    "option4": "keyInput",
    "option5": "keyEnter",
    "solution": "keyPressed"
  },
  {
    "question": "Which container splits two components horizontally or vertically?",
    "option1": "JSplitPane",
    "option2": "JSeparator",
    "option3": "JPanel",
    "option4": "JFrame",
    "option5": "JSlidePane",
    "solution": "JSplitPane"
  },
  {
    "question": "Which method adds tooltip text to a Swing element?",
    "option1": "setHint()",
    "option2": "addTooltip()",
    "option3": "Tooltip()",
    "option4": "setToolTipText()",
    "option5": "setDescription()",
    "solution": "setToolTipText()"
  },
  {
    "question": "JTable relies on which model?",
    "option1": "TreeModel",
    "option2": "ComboModel",
    "option3": "TableModel",
    "option4": "GridModel",
    "option5": "NodeModel",
    "solution": "TableModel"
  },
  {
    "question": "Which thread handles Swing event processing?",
    "option1": "WorkerThread",
    "option2": "RenderThread",
    "option3": "Event Dispatch Thread",
    "option4": "UIThread",
    "option5": "UpdateThread",
    "solution": "Event Dispatch Thread"
  },
  {
    "question": "Which Swing component allows selection of multiple check options?",
    "option1": "JCheckBox",
    "option2": "JButton",
    "option3": "JTreeNode",
    "option4": "JProgressBar",
    "option5": "JToggleButton",
    "solution": "JCheckBox"
  },
  {
    "question": "Which listener handles window close events?",
    "option1": "ActionListener",
    "option2": "MouseListener",
    "option3": "WindowListener",
    "option4": "FocusListener",
    "option5": "KeyListener",
    "solution": "WindowListener"
  },
  {
    "question": "The content container of JFrame is:",
    "option1": "Root Pane",
    "option2": "Glass Pane",
    "option3": "Content Pane",
    "option4": "UI Pane",
    "option5": "Base Pane",
    "solution": "Content Pane"
  },
  {
    "question": "Which class is used for modal pop-up windows?",
    "option1": "JDialog",
    "option2": "JFrame",
    "option3": "JPanel",
    "option4": "JPopup",
    "option5": "JWindow",
    "solution": "JDialog"
  },
  {
    "question": "Which Swing component supports both icons and text?",
    "option1": "JLabel",
    "option2": "JWindow",
    "option3": "JButton",
    "option4": "JTable",
    "option5": "JSplitPane",
    "solution": "JButton"
  },

  {
    "question": "Which layout manager offers highest flexibility but complexity?",
    "option1": "GridLayout",
    "option2": "BorderLayout",
    "option3": "GridBagLayout",
    "option4": "FlowLayout",
    "option5": "CardLayout",
    "solution": "GridBagLayout"
  },
  {
    "question": "Which class handles tree nodes?",
    "option1": "DefaultTreeNode",
    "option2": "MutableTreeNode",
    "option3": "DefaultMutableTreeNode",
    "option4": "TreeNodeChild",
    "option5": "NodePane",
    "solution": "DefaultMutableTreeNode"
  },
  {
    "question": "Which method refreshes UI after Look & Feel change?",
    "option1": "SwingUtilities.updateComponentTreeUI",
    "option2": "refreshUI()",
    "option3": "updateLook()",
    "option4": "changeUI()",
    "option5": "reloadUI()",
    "solution": "SwingUtilities.updateComponentTreeUI"
  },
  {
    "question": "Which component is ideal for displaying HTML?",
    "option1": "JEditorPane",
    "option2": "JTextField",
    "option3": "JList",
    "option4": "JBox",
    "option5": "JScrollBar",
    "solution": "JEditorPane"
  },

  {
    "question": "Which thread is recommended for updating Swing components?",
    "option1": "Main Thread",
    "option2": "Worker Thread",
    "option3": "Event Dispatch Thread",
    "option4": "Network Thread",
    "option5": "Render Thread",
    "solution": "Event Dispatch Thread"
  },
  {
    "question": "Swing's painting system internally uses:",
    "option1": "Single-buffered model",
    "option2": "Hardware rasterizer",
    "option3": "Double-buffering",
    "option4": "Native OS drawing",
    "option5": "SWT paint cycle",
    "solution": "Double-buffering"
  },

  {
    "question": "Which code snippet creates a JFrame titled 'Home'?",
    "option1": "JFrame f = new JFrame(); f.setName(\"Home\");",
    "option2": "Frame f = new Frame(\"Home\");",
    "option3": "JFrame f = new JFrame(\"Home\");",
    "option4": "JWindow f = new JWindow(\"Home\");",
    "option5": "JFrame f = JFrame.get(\"Home\");",
    "solution": "JFrame f = new JFrame(\"Home\");"
  },

  {
    "question": "Which JTable setup allows editable cells?",
    "option1": "EditableTableModel",
    "option2": "ReadOnlyModel",
    "option3": "TreeTableModel",
    "option4": "StaticModel",
    "option5": "LockedModel",
    "solution": "EditableTableModel"
  },

  {
    "question": "What happens if Swing UI is updated outside EDT?",
    "option1": "Possible race conditions and UI glitches",
    "option2": "Frame closes automatically",
    "option3": "App switches to AWT mode",
    "option4": "Look & Feel resets",
    "option5": "Thread crashes immediately",
    "solution": "Possible race conditions and UI glitches"
  },
  {
    "question": "Which method is overridden for custom painting?",
    "option1": "paint()",
    "option2": "updateUI()",
    "option3": "paintComponent(Graphics g)",
    "option4": "render()",
    "option5": "draw()",
    "solution": "paintComponent(Graphics g)"
  },

  {
    "question": "What will this code print?\nJLabel l = new JLabel(); l.setText(\"Hi\"); System.out.println(l.getText());",
    "option1": "null",
    "option2": "Hi",
    "option3": "Empty",
    "option4": "Label",
    "option5": "None",
    "solution": "Hi"
  },

  {
    "question": "Which Swing component supports custom cell rendering?",
    "option1": "JTree",
    "option2": "JTable",
    "option3": "JScrollPane",
    "option4": "JDialog",
    "option5": "JPanel",
    "solution": "JTable"
  },

  {
    "question": "Which is the correct way to safely update a JLabel from a background thread?",
    "option1": "label.setText(\"Done\");",
    "option2": "Thread.sleep(1); label.setText(\"Done\");",
    "option3": "SwingUtilities.invokeLater(() -> label.setText(\"Done\"));",
    "option4": "label.updateUI();",
    "option5": "runLater(label);",
    "solution": "SwingUtilities.invokeLater(() -> label.setText(\"Done\"));"
  }
]
